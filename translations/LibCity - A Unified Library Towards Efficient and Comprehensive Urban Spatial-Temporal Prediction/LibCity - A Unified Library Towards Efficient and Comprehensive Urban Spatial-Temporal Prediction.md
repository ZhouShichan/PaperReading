# LibCity: A Unified Library Towards Efficient and Comprehensive Urban Spatial-Temporal Prediction

## 摘要

随着深度学习技术的进步和更多城市时空数据的积累，越来越多的深度学习模型被提出来解决城市时空预测问题。然而，现有领域存在局限性，包括开源数据格式多样且难以使用，很少有论文公开其代码和数据，以及开源模型通常使用不同的框架和平台，使得比较具有挑战性。迫切需要一个标准化的框架来实施和评估这些方法。为了解决这些问题，我们提出了 LibCity，这是一个开源库，为研究人员提供了可靠的实验工具和方便的开发框架。在这个库中，我们复制了65个时空预测模型，收集了55个时空数据集，使研究人员能够方便地进行综合实验。通过实现公平的模型比较、设计统一的数据存储格式以及简化开发新模型的过程，LibCity 有望为时空预测领域做出重大贡献。

## 关键词

时空预测，开源库

## 引言

近年来，随着城市地区传感器技术的进步，可以收集大量数据，为利用人工智能技术解决城市预测问题提供了新的视角[1]。解决时空预测问题在城市计算中至关重要，有助于智慧城市的管理和决策过程，提高居民的生活水平。城市时空预测具有多种应用，包括拥堵控制[2]、路线规划[3]、车辆调度[4]和POI推荐[5]。

文献中提出了许多城市时空预测技术。不幸的是，我们发现在11个主要会议和期刊上发表的论文中，只有不到30%的论文将其代码和数据开源，这给该领域带来了可重复性的挑战[6]。此外，这些模型通常是在不同的平台或框架下实现的，这使得研究人员难以统一的方式重现结果。特别是，特定数据集上的预测模型的准确性对超参数的选择很敏感。如果没有一个公开的、统一的标准数据集来对模型性能进行基准测试，就越来越难以衡量新的时空预测方法的有效性，也越来越难以公平地比较不同模型的性能[1,7]。

相比之下，计算机视觉、自然语言处理和推荐系统等领域拥有标准化数据集，如 IMAGENET [8] 和 MMDetection [9] 和 RecBole [10] 等算法库。不幸的是，城市时空预测缺乏这些资源。因此，我们亟需开发一个将城市时空预测全方位考虑的标准化库。为了应对这些挑战，我们推出了 LibCity[1]，一个支持模型标准化测量的开源库。通过提供城市时空预测的标准库，我们旨在提高该领域的可重复性、可比性和进步。

LibCity 的主要特点可以概括为以下四个方面：

- 统一和模块化的框架设计：LibCity 采用全面和标准化的方法来实施、部署和评估时空预测模型。该库完全基于 PyTorch [11] 构建，包括五个模块：配置、数据、模型、评估和执行。每个模块都有一个明确定义的范围，并与其他模块无缝协作，以提供库的完整功能。我们在这些模块中设计了基本的时空数据存储、统一的模型实例化接口和标准化的评估程序。用户可以通过简单的配置轻松训练和评估现有模型。另一方面，开发人员可以只专注于与其模型相关的接口，而不必担心其他模块的实现细节。
- 通用和可扩展的数据存储格式：开源时空数据集有多种存储格式。为了提供用户友好的界面并确保图书馆的统一性，LibCity为城市时空数据开发了一种通用且可扩展的数据存储格式，即原子文件。这些原子文件由五个类别组成，分别表示时空数据中的最小信息单位，包括地理单位数据、用户单位数据、单位关系数据、时空动态数据和外部数据。原子文件是一种通用且可扩展的结构，可以一致地表示时空数据。使用原子文件，LibCity 开发了数据处理功能和批量提取工具，以创建统一的数据处理流程，最大限度地减少开发新模型所需的工作量。Batch 是 LibCity 中模型的标准化输入格式。
- 全面的基准任务、数据集和模型：为了提高数据集库的全面性，我们收集了来自11个不同国家的55个广泛使用的时空数据集，涵盖不同时期，并将它们处理成原子文件。我们还复制了 65 个经典的时空预测模型，包括最先进的模型，涵盖三个类别和九个子类别的任务：宏观组预测任务（例如，交通流量预测、交通速度预测、按需服务预测、交通事故预测、OD 矩阵预测）、微观个体预测任务（例如，轨迹下一个位置预测、旅行时间预测）和基本任务（例如， 地图匹配和道路网络表示学习）。此外，我们还实现了丰富的辅助功能，如自动参数调优和可视化平台，以方便这些数据集和模型的使用。我们将不断将更多的数据集和模型整合到我们的库中，以提供更全面的基准测试任务。
- 多样化和灵活的评估指标：LibCity 提供一系列标准评估指标，用于评估不同类型的时空预测模型。这些指标涵盖了分类和回归等典型任务，确保了全面的模型性能评估。此外，LibCity 还提供灵活的评估策略。对于宏观级别的预测任务，可以使用数据切片和窗口设置来确定训练、验证和测试数据集的分区方式以及单步和多步预测的输入/输出数据长度。对于微观级别的预测任务，窗口设置支持对轨迹进行分区，以评估模型在长、中、短轨迹上的性能。通过结合评估指标、数据集划分和窗口设置，用户可以对属于同一任务的模型进行多样化和灵活的评估。

据我们所知，LibCity是第一个用于城市时空预测的开源库。我们认为它是探索和开发时空预测模型的重要资源。通过实现公平的模型比较、设计统一的数据存储格式以及简化开发新模型的过程，LibCity 有望为时空预测领域做出重大贡献。此外，LibCity 还帮助建立该领域的评估标准，并促进其快节奏和标准化的发展。

## 2 相关工作

## 2.1 城市时空预测

时空预测问题可以抽象为时间序列预测问题，即利用一系列历史时空因素来预测时空目标。根据预测目标的类型，时空预测任务可细分为宏观状态预测和微观个体预测。宏观状态状态是在宏观层面描述时空状况的状态，如交通流量、交通速度、按需服务等。微观个体预测是从微观层面预测单个用户的行为，如轨迹下一个位置预测、行程时间估计、路线规划等。

一般来说，无论任务类型如何，时空预测方法都可以分为两种类型：传统方法和深度学习方法。传统方法主要基于统计假设进行序列预测，如隐马尔可夫模型（HMM）[12]、支持向量回归（SVR）[13]和基于矩阵分解的FPMC-LR方法[14]。然而，这些方法都是浅层模型，捕获时空数据的非线性能力有限，因此，这些方法在实践中表现不佳。与传统方法相比，深度学习方法具有更强的特征学习能力，能够自动从时空数据中提取特征，从而能够更好地捕捉时空相关性。因此，卷积神经网络（CNN）、递归神经网络（RNN）和图卷积网络（GCN）等各种深倾模型在时空预测领域取得了巨大的成功。由于RNN在序列数据建模方面的强大能力，RNN在以往的研究中常用于对时空数据的时间相关性进行建模。在空间相关性建模方面，经常使用CNN或GCN。传统的CNN模型只能对欧几里得数据进行建模，因此研究人员通常将不同时间的时空网络结构转换为图像。此外，GCN模型，包括空间方法和谱方法，可以直接对图结构的时空数据进行建模，并取得了最先进的结果。 最近，空间和时间注意力机制也被引入到时空预测领域，以自适应地为时空数据分配不同的重要性，以捕捉动态的时空相关性。

## 2.2 相关开源库

据我们所知，LibCity [6] 是第一个时空预测库，使研究人员能够进行全面的比较实验并开发新模型。最近，其他研究人员提出了类似于LibCity的时空预测基准。DL-Traff [15] 是一个开源项目，使用基于网格和基于图形的模型提供流量预测基准。DGCRN [16] 总结了以往的工作，并得出了流量预测的基准。但是，这两个项目仅积累了过去研究工作的模型代码，而没有模块化设计，这使得用户使用不便。此外，它们只关注宏观层面的流量预测，而不涉及微观层面的单个预测任务。微软 FOST[2]（Forecasting Open Source Tool）是一个通用的预测工具，旨在为时空预测提供一个易于使用的工具，但其支持的模型和应用有限。

此外，值得注意的是，在其他研究领域也有许多类似的实验库。例如，RecBole[10] 是一个推荐算法框架，它再现了大量的推荐模型，提供了各种评估策略和数据预处理操作，使实验变得容易。同时，MMDetection [9] 采用模块化设计，使研究人员能够基于它有效地开发用于目标检测任务的新模型。FastReID [17] 不断复制最先进的模型，并发布相应的预训练模型，用于研究和工业目的。

LibCity 结合了上述库的优势，例如各种基线模型、多样化的评估策略和模块化设计。因此，它不仅方便了研究人员进行实验和开发新模型，而且还促进了时空预测领域的标准化。

## 3 时空数据

### 3.1 城市时空数据

在现代城市中，物联网（IoT）传感器、GPS终端、智能手机、基于位置的服务（LBS）、射频识别（RFID）和可穿戴智能手环等城市信息基础设施设备众多，它们收集了大量与城市相关的时空大数据。

常见的城市时空数据包括三类：

1) 城市场景数据： 这类数据是低频、静态的城市结构数据，如城市地图数据、兴趣点（POI）数据、城市路网数据等。
2) 个体行为数据：这类数据一般是物联网数据，是高频、动态的时空轨迹数据，如浮动车GPS数据、公交卡数据、手机信令数据、基于位置的社交网络（LBSN）数据等。
3) 群体动态数据：这类数据一般是群体行为的聚合数据，是高频、动态的时空属性数据，如人口密度、交通路况、乘车需求、始发地-目的地（OD）网络、气候、天气数据等。

城市时空数据的特点是随时间和空间的动态变化。主要城市兴趣点和道路网络的分布是时空静态数据的示例。另一方面，物联网传感器记录的城市交通流量数据和天气数据被认为是空间静态和时间动态数据。相比之下，用户轨迹数据和签到数据是时空动态数据的例子，它们捕捉了个人在时间和空间上的运动和行为。

### 3.2 原子文件

现有的开源时空数据集通常以不同的格式存储，如NPZ、PKL、H5、CSV等，这必然增加了用户使用这些数据集的难度和负担。因此，为了提供城市时空数据的统一表示和存储格式，我们定义了五种类型的原子文件，即城市时空数据的五个最小信息单元如下：

- 地理单元数据：地理单元数据是空间-时间数据中的基本单位，即点、线和面。
- 用户单元数据：用户单元数据描述了脱敏城市活动参与者的属性信息。
- 单元关系数据：单元关系数据描述了城市空间-时间预测场景中单元之间的关系。
- 空间-时间动态数据：空间-时间动态数据描述了城市中随时间动态变化的实体的属性信息，包括空间静态时间动态（SSTD）数据和空间动态时间动态（SDTD）数据。
- 外部数据：外部数据描述了与城市地理和用户单元相关的辅助信息。

对于上述五种类型的原子文件，我们使用逗号分隔值格式进行数据存储，并为不同种类的原子文件定义了不同的文件后缀。此外，我们限制了原子文件中每一行中包含的信息。例如，“.geo”文件必须包含ID、地理实体类型（点、线、多边形）和坐标信息。其他属性必须存储在上述三列之后，如POI类别或道路宽度。更多详情可参见表1。

<table>
<caption>表1：原子文件摘要</caption>
<th>后缀</th><th>内容</th>
<tr><td>.geo</td><td>地理单位数据</td></tr>
<tr><td>.usr</td><td>用户单位数据</td></tr>
<tr><td>.rel</td><td>单位关系数据</td></tr>
<tr><td>.dyna</td><td>用户单位的空间动态时间动态 （SDTD） 数据（轨迹）</td></tr>
<tr><td>.dyna</td><td>图网络单位关系数据的空间静态时态动态（SSTD）数据</td></tr>
<tr><td>.grid</td><td>用于网格关系数据的空间动态时态动态 （SDTD） 数据</td></tr>
<tr><td>.od</td><td>OD 关系数据的空间动态时态动态 （SDTD） 数据</td></tr>
<tr><td>.gridod</td><td>网格 OD 关系数据的空间动态时态动态 （SDTD） 数据</td></tr>
<tr><td>.ext</td><td>外部数据</td></tr>
</table>

## 4 空间-时间预测任务

城市时空预报任务的主要目的是根据历史观测对城市时空数据进行预测，包括空间静态时空动态（SSTD）数据和空间动态时空动态（SDTD）数据。我们将主要的时空预测任务分为两类，一类是宏观组预测任务，另一类是微观个体预测任务。除了这两类时空预测任务外，本文还考虑了一些支持城市时空预测的基本任务。具体而言，本研究的目标任务如下：

### 4.1 宏观群体预测任务

此类任务主要用于空间静态时态动态 （SSTD） 数据。具体而言，这些任务用于预测宏组未来的时空属性。从形式上讲，给定SSTD数据，我们的目标是从前面 $T$ 步骤的观测值中学习映射函数 $f$ ，以预测未来 $T'$ 步骤的属性[7,18]，
$$[\boldsymbol{X}_{(t-T+1)},\cdots,\boldsymbol{X}_t;\mathcal{G}]\xrightarrow{f}[\boldsymbol{X}_{(t+1)},\cdots,\boldsymbol{X}_{(t+T')}].(1)$$
其中，张量X可以从图关系数据，网格关系数据，OD关系数据，和网格OD关系数据中获得。

典型的宏观群体预测任务包括交通流量预测，交通速度预测，按需服务预测，起点-终点矩阵预测，和交通事故预测，如下所述：

- *交通流量预测* [19,20] 旨在预测未来时间窗口内进入或离开特定区域或路段的车辆数量。准确的预测可以显著改善动态交通控制、路线规划、导航服务和其他高级应用。
- *交通速度预测*[21,22] 旨在预测未来特定路段上车辆的平均速度。这里的交通速度是指单位时间内行驶的距离，重点是车辆在特定路段上的平均速度，而不是特定车辆。此任务类似于交通流预测，这两个问题都可以使用类似的预测策略来解决。
- *按需服务预测*[23,24] 旨在预测特定地区或路段的乘车请求数量。短期需求预测对于优步和滴滴等按需叫车平台至关重要，因为动态定价依赖于实时需求预测，而调度系统可以将司机重新安置到高需求地区。通常，接送次数表示特定时间间隔内特定区域的需求。
- *起点-终点矩阵预测*[25,26] 旨在预测不同节点之间的转换，也称为边缘流或基于起点-目的地的流。与其他交通预测任务相比，OD预测可以更详细地洞察出行需求，并增强对城市交通模式的理解。
- *交通事故预测*[27,28] 对于改善公共安全至关重要。然而，从交通事故的位置和时间来预测交通事故的发生通常是困难的。在最近的研究中，研究人员已将重点转移到预测特定地区的交通事故数量或交通风险的严重程度上。这些风险级别最高的地区可以被视为热点，可以实施有针对性的安全措施。

### 4.2 微观个体预测任务

此类任务主要用于空间动态时空动态 （SDTD） 数据。具体而言，这些任务根据用户的历史轨迹数据执行特定于任务的标签预测。从形式上讲，给定 SDTD 数据，我们的目标是从用户的历史轨迹 $𝒯$ 中学习映射函数 $f$ ，以预测特定于任务的标签 [29,30]，
$$\mathcal{T}=[\langle\boldsymbol{v}_i,t_i\rangle]_{i\boldsymbol{=}1}^m\xrightarrow{f}label.(2)$$
其中，样本点 $\boldsymbol{v}_i$ 可以是上述点、线或平面地理单元。换句话说，轨迹 $\mathcal{T}$ 可以是基于 GPS 的轨迹、基于 POI 的轨迹、基于路网约束的轨迹和基于区域/网格的轨迹。典型的微观个体预测任务包括轨迹下一位置预测和旅行时间预测（也称为预计到达时间，ETA），具体如下：

- *轨迹下一步位置预测* [25]、[26] 旨在根据用户的历史轨迹，预测该用户下一步可能访问的位置。形式上，给定用户 $i$ 的历史轨迹 $\mathcal{T} = [\langle\boldsymbol{v}_i,t_i\rangle]_{i=1}^m$，我们的目标是估计用户 $i$ 在下一个时间戳 $t_{m+1}$ 中的位置 $v{m+1}$ 的概率。大多数下一个位置预测研究都集中在基于 POI 的轨迹上
- *旅行时间预测* [27]、[28] 的目的是根据轨迹和出发时间预测到达时间。给定轨迹序列 $\{\boldsymbol{v}_1,\ldots,\boldsymbol{v}_m\}$ 和出发时间 $t_1$，我们的目标是通过 $\{\boldsymbol{v}_1,\ldots,\boldsymbol{v}_m\}$ 估算起点 $v_1$ 和终点 $v_m$ 之间的旅行时间。此外，在某些 ETA 场景中，只给出了起点、出发时间和目的地，而没有具体的轨迹序列。旅行时间预测研究的重点是基于 GPS 的轨迹、受路网约束的轨迹以及基于区域或网格的轨迹。

### 4.3 基本任务

基础任务为上述宏观和微观预测任务提供支持。这项工作考虑的基本任务包括地图匹配和道路网络表示学习。

- *地图匹配* [35，36] 旨在将原始 GPS 轨迹与道路网络的路段相匹配。给定一个基于GPS的轨迹 $𝒯^{gps}$ 和一个道路网络 $\mathcal{G}=(\mathcal{V},\mathcal{E},\mathcal{F}_\gamma,\mathcal{A})$ ，我们的目标是找到一个与 $𝒯^{gps}$ 真实路径相匹配的道路网络约束轨迹 $𝒯^{gps}$。
- *道路网络表示学习* [37，38] 旨在从原始道路网络数据中发现表示，类似于网络嵌入方法[39]。给定一个包含原始属性的道路网络 $\mathcal{G}=(\mathcal{V},\mathcal{E},\mathcal{F}_\gamma,\mathcal{A})$ ，我们的目标是为 $\mathcal{G}$ 上的每个路段派生一个 𝑑-维表示 $F_{\mathcal{V}}^{dense}\in\mathbb{R}^{N\times d}$, 其中 $d\ll D$ 。$F_{\mathcal{V}}^{dense}$ 应该保留 $F_{\mathcal{V}}$ 的多方面特征。

## 5 开源库：LibCity

<div style="text-align:center">
<image src="asset\libcity_frame.png" width="100%" />
<caption style="text-align:center"> 图 1：LibCity 库概述</caption>
</div>

近年来，深度学习算法在城市时空预测中得到了广泛的应用，产生了丰富的研究成果。然而，根据我们的调查，在11个主要会议和期刊上发表的论文中，只有不到30%的论文将其代码和数据开源，这阻碍了该领域的可重复性。此外，对公认的最先进的（SOTA） 模型、标准化数据集和透明实验设置的需求为评估新模型的性能带来了障碍，并最终扼杀了创新。相比之下，计算机视觉、自然语言处理和推荐系统等领域拥有标准化数据集，如 IMAGENET [8] 和 MMDetection [9] 和 RecBole [10] 等算法库。不幸的是，城市时空预测缺乏这些资源。为了解决这个问题，我们提出了一个全面而统一的城市时空预测库LibCity。

图 1 展示了 LibCity 的框架，该框架由五个主要模块组成，包括数据、模型、评估、执行和配置模块。这些模块组合形成一个有凝聚力的管道，为研究人员提供可靠的实验环境，每个模块负责管道中的特定步骤。后续部分将详细介绍每个模块的实现。

- 数据模块：负责数据集的加载和数据预处理。
- 模型模块：负责初始化复制的基线模型或自定义模型。
- 评估模块：负责通过多个指标评估模型预测结果。
- 执行模块：负责模型训练和预测。
- 配置模块：负责管理框架中涉及的所有参数。

### 5.1 数据模块

我们的数据模块旨在通过建立标准化的数据处理流程，解决不同数据制备方法导致的不公平评价问题，如图2所示。此流包含两种类型的数据：面向用户的数据和面向模型的数据。前者为时空数据建立了统一的存储格式，称为原子文件，为用户提供了一致的数据输入格式。后者定义了一个键值数据结构，称为 Batch，以促进数据模块和模型模块之间的统一数据交互。加载并预处理原子文件后，将使用 PyTorch 中的 Dataloader 类将数据转换为 Batch 结构，然后馈送到模型模块。

<div style="text-align:center">
<image src="asset\data_processing_flow.png" width="100%" />
<caption style="text-align:center"> 图2：LibCity的数据处理流程</caption>
</div>

#### 5.1.1 原子文件

LibCity为城市时空数据（即原子文件）定义了一种通用且可扩展的数据存储格式。原子文件包含五个类别，即时空数据中的次要信息单元。有关更多详细信息，请参阅上面的第 3.2 节。

#### 5.1.2预处理操作

LibCity 库支持各种数据预处理操作。对于宏观组预测任务，必须对时空数据进行归一化，以提高模型向最优解的收敛性。LibCity 支持多种数据归一化方法，包括 Z 分数归一化、最小-最大归一化、对数归一化等自定义归一化方法，通过参数设置即可轻松实现。LibCity 还支持处理缺失值和异常值。对于微观个体预测任务，LibCity 结合了两种轨迹过滤方法：非活动用户过滤和非活动 POI 过滤。通过根据轨迹的数量和长度评估其活动并设置最小轨迹数和最小轨迹长度，可以过滤掉非活动用户。同样，可以根据最小访问次数过滤掉非活动 POI。通过这种方式，我们可以过滤数据以减少稀疏性对时空数据的影响。

#### 5.1.3 批处理

Batch 是基于 python.dict 实现的键值数据结构。它由作为键的特征名称和相应的特征张量（torch.Tensor） 作为小批量的值。Batch 的目的是促进系统管道中数据模块和模型模块之间的数据交互。在管道中，执行程序一次从 Dataloader 中提取一个 Batch 对象，并将其馈送到模型中。这种结构可以通过引用相应的特征名称来方便地使用特征张量。由于不同的预测模型使用不同的特征，因此它们都可以以 Batch 的形式存储。通过这种数据形式，LibCity可以构建统一的模型接口，并实现用于模型训练和测试的通用执行器，这对于开发新模型特别有用。

#### 5.1.4 综合数据集

我们开展了关于时空预测的综合文献调查，选取了351篇具有代表性的论文，包括调查论文。我们确定了这些论文中使用的所有开放数据集，并根据它们的受欢迎程度、时间跨度长度和数据大小选择了 55 个数据集。这些数据集涵盖了 LibCity 支持的所有 9 个任务，包括 40 个群体动力学数据集（SSTD 数据）、10 个个体行为数据集（SDTD 数据）和 5 个城市场景数据集（道路网络数据）。表二、表三和表四提供了这些数据集的统计数据。为了方便在 LibCity 中使用这些数据集，我们已将它们全部转换为原子文件格式并创建了转换工具，可以在此链接 3 中找到。

<!-- TODO：表格 -->

### 5.2 模型模块

为了增加库的模块化，减少不同模块之间的耦合，LibCity使用单独的模型模块来实现经典的时空预测算法。该模块包含各种型号，例如 LSTM、GRU、TCN、GCN 等。LibCity 将每个模型封装在一个单独的类中，使用户能够轻松地在不同模型之间切换，并使用新模型扩展库。

#### 5.2.1 统一接口

具体来说，LibCity 为所有城市时空预测模型提供了两个标准接口：predict（） 和 calculate_loss（） 函数，如下所示：

- 在模型预测过程中使用 predict（） 函数返回模型预测结果。
- 模型训练过程中使用 calculate_loss（） 函数返回损失值，这是需要优化的目标。

这两种方法都采用内部数据表示形式 Batch 作为输入。这些接口函数适用于不同的时空预测模型，这使得研究人员能够以高度统一的方式实现各种模型。在开发新模型时，研究人员只需要实例化这两个接口即可与 LibCity 中的其他模块连接。他们不需要担心其他每个部分是如何工作的。这种设计简化了开发过程，并加快了新模型的开发。

### 5.2.2 实现的模型

目前，LibCity 支持 9 个主流的时空预测任务。通过对时空预测领域的发展过程的仔细研究，我们选择了65个经典的时空预测模型进行复制，从早期的基于CNN的模型到最近的基于GCN的模型和混合模型。此外，为了覆盖广泛的预测模型，我们还实现了四个浅基线模型。我们已经在至少两个数据集上测试了所有已实现模型的性能。我们在表V中总结了已实现的65个模型，参考LABEL：macro_models部分，我们还在表中提供了模型在空间和时间维度上的不同基本结构。用户可以参考此表，了解城市时空预测领域的主要技术和发展。

### 5.3 评估模块

通过标准化的数据处理流程和预测模型接口，LibCity还为时空预测任务提供了标准的评估程序。由于模型输出格式和评估指标可能因不同的时空预测任务而异，因此 LibCity 为每个任务开发了特定的评估器，并支持各种流行的评估指标。

#### 5.3.1评估指标

**回归任务指标：**在 LibCity 中，回归任务包括交通流量预测、交通速度预测、按需服务预测、始发地-目的地矩阵预测、交通事故预测和出行时间预测。这些任务输出实数，并使用常用的基于值的指标进行评估，这些指标包括平均绝对误差 （MAE）、均方误差 （MSE）、均方根误差 （RMSE）、平均绝对百分比误差 （MAPE）、决定系数 （ $𝑅^2$ ） 和解释方差分数 （EVAR）。这些指标的计算公式如下：
$$MAE=\frac1n\sum_{i=1}^n|\hat{y_i}-y_i| $$
$$MSE=\frac{1}{n}\sum_{i=1}^{n}\binom{\hat{y}_{i}-y_{i}}{i}^{2} $$
$$RMSE=\sqrt{\frac{1}{n}\sum_{i=1}^{n}\binom{\hat{y}_{i}-y_{i}}{2}} $$
$$MAPE=\frac{1}{n}\sum_{i=1}^{n}\left|\frac{\hat{y}_{i}-y_{i}}{y_{i}}\right|^{*}100\% $$
$$R^{2}=1-\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}}{\sum_{i=1}^{n}\left(y_{i}-\bar{y}\right)^{2}} $$
$$EVAR=1-\frac{Var_{\begin{pmatrix}y_i-\hat{y}_i\end{pmatrix}}}{Var_{\begin{pmatrix}y_i\end{pmatrix}}} $$

其中$y=\{y_1,y_2,...,y_n\}$是真值，$\hat{y}=\{\hat{y}_1^{\wedge},\hat{y}_2^{\wedge},...,\hat{y}_n^{\wedge}\}$是预测值，$n$是样本数，$y=\frac1n\sum_{i=1}^ny_i$是平均值，$Var(y_i)=\frac1n\sum_{i=1}^n(y_i-y)^2$是方差。

**分类任务的指标：**LibCity 中的分类任务是轨迹下一个位置预测。此任务在 LibCity 中的输出是候选者下一个位置的概率分布。轨迹下一个位置预测任务使用各种基于排名的指标进行评估，包括 Precision@K、Recall@K、F1-score@K、MRR@K（平均倒数 Rank@K）和 NDCG@K（归一化贴现累积Gain@K）。这些指标的计算公式如下：
$$Precision@K=\frac{\sum_{i=1}^{N}\left|\operatorname{Hit}(^i)\right|}{N\times K}$$
$$Recall@K=\frac{\sum_{i=1}^N\left|\operatorname{Hit}(^i)\right|}N$$
$$F1@K=\frac{2\times\text{ Precision@ }\times\text{ Recall@ }K}{\text{Precision }@+\text{ Recall@ }K}$$
$$MRR@K=\frac{1}{N}\sum_{{i\operatorname{=}1}}^{N}\frac{1}{\operatorname{Rank}(^{i})}$$
$$NDCG@K=\frac{1}{N}\sum_{i=1}^{N}\frac{1}{\log_{2}\left(\mathrm{~rank}(^{i})^{+1}\right)}$$

其中$N$是测试数据的数量，$i$是第 $i$ 个测试数据，$K$是用于评估的顶部$K$预测输出，$T(i)$是第 $i$ 个测试数据中的真实下一跳位置，$R(i)$是第 $i$ 个测试数据的预测结果中前 K 个位置的集合， $Hit(i)$是第 $i$ 个测试数据中预测命中位置的集合，也就是 $T(i)\cap R(i)$。$Rank(i)是在第 $i$ 个测试数据 T(i)$ 在 $R(i)$ 的排名，并且是 |*|集合的模算子。

**基本任务的指标：**LibCity 中的基本任务为宏观和微观预测任务提供支持，包括地图匹配和道路网络表示学习。道路网络表示任务需要与特定的下游任务相结合，以评估表示向量的性能。例如，如果使用路段分类任务进行评估，则该任务是分类任务。如果使用道路流量预测任务进行评估，则为回归任务。这些任务的评估指标与上述指标类似。这里我们重点介绍地图匹配任务的评估指标。

LibCity 使用三个指标来评估地图匹配任务：RMF（路线不匹配分数）、AN（数字精度）和 AL（长度精度），这些指标在以前的工作中使用过，例如 [12，97]。
$$RMF=\frac{d_-+d_+}{d_0} $$
$$AN=\frac{\#Rc}{\#R} $$
$$AL =\frac{\sum{len}({Rc})}{\sum{len}(R)} $$
其中 $d_0$ 表示从误差中减去的长度， $𝑑_+$ 表示误差中增加的长度， $𝑑_−$ 是实迹路径的总长度， $𝑅𝑐$ 表示正确匹配的道路， $𝑅$ 表示实迹路线的所有道路。 $𝑙en()$ 表示一组道路的长度。

#### 5.3.2 评估策略

为了灵活地评估时空预测模型的性能，LibCity提供了两种主要策略。

首先，用户可以按照自己选择的比例将数据集划分为训练集、验证集和测试集。训练集用于模型训练，而验证集用于超参数调整和防止过拟合。测试集用于评估训练模型的最终性能。

其次，LibCity 允许用户设置不同的窗口大小进行评估。对于宏组预测任务，用户可以设置各种输入和输出时间窗口，LibCity 会根据窗口大小对输入数据进行分区，从而利用不同长度的历史观测值进行多步预测。对于微观单个预测任务，轨迹根据窗口设置进行拆分，并可选择基于时间或基于长度的窗口。用户可以设置窗口大小和类型，以评估模型在不同长度轨迹（如长、中和短轨迹）上的性能。

这两种策略可以与各种评估指标相结合，对同一任务的模型进行综合评估，为评估模型性能提供更大的灵活性和适应性。

### 5.4 执行模块

LibCity 中的执行模块充当控制其他模块之间交互的中心枢纽，以促进模型训练和性能评估。用户可以修改本模块的参数设置，调整模型训练的效果。支持多种模型训练策略，优化模型，内置自动超参数调优模块，减少用户工作量，实现模型自动优化。

#### 5.4.1 模型训练技术

LibCity 提供各种训练技术来有效地训练深度神经网络。这些技术可以通过修改执行模块的参数设置来自定义。以下是 LibCity 支持的一些技术：

- *优化器选项*：在深度学习模型的训练过程中，优化器主要用于更新网络的参数，以最小化损失函数。LibCity 支持多种优化器，包括 SGD [104]、RMSProp [105]、Adam [106] 和 AdaGrad [107]。不同的优化算法对网络参数的更新方式不同，更适合不同的场景。用户可以针对自己的使用场景选择合适的优化算法，以获得更好的训练效果。
- *学习率调整策略*：学习率是神经网络模型的关键参数，它控制着基于梯度的网络权重调整速度，并决定损失函数向最优解的收敛程度。
- *损失函数选项*：深度学习中使用了各种损失函数，不同的损失函数以不同的方式计算损失，以获得不同的训练结果。LibCity 支持五种类型的损失函数，包括交叉熵损失、L1 损失、L2 损失、Huber 损失 [108]、LogCosh 损失 [109] 和分位数损失 [110]。
- *提前停止*：随着训练轮次的增加，可能会发生过度拟合。LibCity 支持早期停止方法，以防止过拟合。用户可以通过参数配置指定是否使用提前停止机制和持续时间的大小。
- *梯度裁剪*：训练期间可能会发生梯度爆炸。为了避免这种情况，LibCity支持梯度裁剪策略[111]。用户可以通过参数配置指定是否使用渐变裁剪。

#### 5.4.2 自动超参数调优

超参数调优对深度学习模型的性能有重大影响。为了减轻手动参数调优的负担，LibCity 提供了自动超参数调优机制。我们使用第三方库 Ray Tune[112] 实现此功能，该库支持各种搜索算法，例如网格搜索、随机搜索和贝叶斯优化。用户可以在配置文件中指定需要调优的参数及其搜索空间，并选择调优方法。然后，LibCity 将从搜索空间中多次采样，并以分布式方式运行模型，自动保存最佳参数值和相应的模型预测结果。第 6.2 节中提供了自动超参数调整的示例。

#### 5.5 配置模块

LibCity 利用配置模块来设置整个框架的参数。实验参数配置由三个因素决定：从命令行传递的参数、用户定义的配置文件和 LibCity 中模块的默认配置文件。上述三种参数配置方式的优先级依次递减，优先级较高的参数优先于同名的较低优先级参数。通过这种优先设计，用户可以通过前两种方法灵活调整实验的参数配置。

要通过命令行调整参数，用户在运行 LibCity 时只需使用“–parameter_name”即可。但是，需要注意的是，只允许从命令行传递实验中经常调整的参数，例如批量大小和学习率。为了让用户能够更广泛地修改默认参数，LibCity 允许用户通过命令行传递用户定义的配置文件的名称，然后由系统读取该名称来设置参数配置。

### 5.6 实验管理与可视化平台

我们创建了一个基于 Web 的实验管理和可视化平台，以便方便地使用 LibCity 的模型和数据集进行实验，如图 3（a） 所示。该平台具有用户友好的图形界面和全面的功能，以支持时空预测研究。用户可以轻松上传新数据集并对其进行可视化，如图3（b）所示，该数据集显示了北京交通流数据集的可视化。配置模型参数后，用户可以通过简单的 Web 界面创建新实验，如图 3（c） 所示。然后，他们可以在方便的时候执行实验，并在实验期间查看训练日志。实验执行后，用户可以获取模型对特定指标的评估结果，并将预测结果可视化。此外，该平台还提供实验比较功能，允许用户比较图3（d）所示不同型号的性能。

我们使用 Django 10 、 Vue 11 和 MySQL 12 构建了实验管理和可视化平台。该平台的开源代码可以在 GitHub 上找到 13 。

## 6 LibCity 的使用示例

本节提供了几个使用 LibCity 来帮助用户开始使用该框架的示例。这些示例包括运行现有模型、执行自动参数调整以及向 LibCity 添加新模型。

### 6.1 运行现有模型

在 LibCity 中运行现有模型的一般过程如下：

1. 数据集格式：用户必须下载原始数据集并将其转换为原子文件。
2. 配置设置：用户可以通过配置文件、命令行或 LibCity 的默认参数来配置实验参数。配置模块的参数构成了整个框架的基础。
3. 数据集预处理和拆分：根据用户的参数设置，LibCity 对数据集进行预处理和拆分。用户可以指定自定义数据集除法比率和数据预处理阈值。例如，用户可以过滤掉长度小于 5 的轨迹。
4. 模型初始化：LibCity 根据用户的任务和模型名称选择创建一个模型对象。
5. 训练和评估：一旦数据和模型准备就绪，LibCity 就会调用执行器模块来训练和评估指定数据集上的模型。训练日志、训练模型和模型评估结果会自动保存供用户使用。

上述步骤由 LibCity 的统一入口文件 （run_model.py） 自动执行。用户只需在命令行中执行单个命令即可启动模型运行过程。在运行时必须分别通过 –task、–model 和 –dataset 选项指定三个基本参数，即 task、model 和 dataset。例如，在第二个 GPU 块上对 METR_LA 数据集运行 50 个 epoch 的 GRU 模型需要以下命令：

### 6.2 运行自动参数调优

考虑到超参数调优会显著影响深度学习模型的性能，LibCity 引入了一种自动超参数调优机制，可以根据用户提供的超参数范围轻松优化给定模型。运行自动调谐功能的一般步骤如下：

1. 设置超参数搜索空间。用户必须在 JSON 文件中指定要优化的超参数及其对应的值范围。例如，隐藏层维度参数的搜索空间可以是一组离散的分类变量，例如 [50， 100， 200]。用户可以使用参数 –space_file 指定参数空间文件的文件名。
2. 选择调谐方法。LibCity 使用第三方库 Ray Tune [112] 实现自动超参数调优，支持多种搜索算法，包括网格搜索、随机搜索和贝叶斯优化。用户可以通过指定参数 –search_alg 来选择调优方法。
3. 开始调整过程。用户可以在命令行中执行单个命令来自动调整模型参数。在调优过程中，LibCity 将从搜索空间中对相应的参数值进行采样，并进行模型训练和验证。验证所有示例后，脚本将在终端上输出最佳参数组合，并将其保存到日志文件中。以下是运行自动调优函数的命令示例：python hyper_tune.py –task traffic_state_pred –model GRU –dataset METR_LA –search_alg BasicSearch –space_file sample_space_file

### 6.3 实现新模型

LibCity 的模块化设计和统一的接口定义为用户定义的扩展提供了灵活性和出色的可扩展性。使用 LibCity 开发新的时空预测模型非常简单。使用 LibCity 开发新模型的一般过程如下：

1. 创建一个新的模型文件，并定义一个模型类，该模型类继承自 LibCity 提供的现有模型抽象类。LibCity 支持的所有 9 个任务都实现了它们的抽象类。
2. 实现 __init__（） 函数，根据配置参数初始化模型。输入参数配置包含配置信息。
3. 实现 calculate_loss（） 函数，计算模型训练期间预测结果与真实值之间的损失。模型训练的目标是优化这种损失。
4. 实现 predict（） 函数，在预测过程中返回模型预测结果。
5. 配置新模型的默认参数配置文件，以指定运行模型所需的参数及其值。
6. 运行模型并评估其在所选数据集上的性能。

因此，使用 LibCity 开发新模型的过程很简单，只需实现三个接口，而 LibCity 则处理其他细节，如数据拆分、模型训练和性能评估。这种设计方法简化了新模型的开发过程，并突出了 LibCity 的可扩展性。

#### 7 与现有库的比较

据我们所知，LibCity [6] 是第一个时空预测库，使研究人员能够进行全面的比较实验并开发新模型。最近，其他研究人员提出了类似于LibCity的时空预测基准。本节与其他部分进行比较，以展示 LibCity 的优势。

DL-Traff [15] 是一个开源项目，使用基于网格和基于图形的模型提供流量预测基准。DGCRN [16] 总结了以往的工作，并得出了流量预测的基准。但是，这两个项目仅积累了过去研究工作的模型代码，而没有模块化设计，这使得用户使用不便。此外，它们只关注宏观层面的流量预测，而不涉及微观层面的单个预测任务。Microsoft FOST 14 （预测开源工具）是一个通用的预测工具，旨在为时空预测提供易于使用的工具，但其支持的模型和应用程序有限。

表 VI 表明，LibCity 在可以处理的模型和数据集数量方面优于其他比较工具。此外，LibCity还设计了统一的时空数据存储格式，对推动该领域的标准化有很大帮助。LibCity 的模块化设计允许可扩展性，并使开发人员能够使用其管道轻松创建新模型。大量的 Stars 和 Forks 表明 LibCity 在开源社区中很受欢迎。未解决的问题数量和总问题的数量也表明 LibCity 的开发人员在社区中很活跃，这有助于解决用户查询并促进该领域的进一步发展。

此外，值得注意的是，在其他研究领域也有许多类似的实验库。例如，RecBole[10] 是一个推荐算法框架，它再现了大量的推荐模型，提供了各种评估策略和数据预处理操作，使实验变得容易。同时，MMDetection [9] 采用模块化设计，使研究人员能够基于它有效地开发用于目标检测任务的新模型。FastReID [17] 不断复制最先进的模型，并发布相应的预训练模型，用于研究和工业目的。

LibCity 结合了上述库的优势，例如各种基线模型、多样化的评估策略和模块化设计。因此，它不仅方便了研究人员进行实验和开发新模型，而且还促进了时空预测领域的标准化。

## 8 结论

本文综述了城市时空预测，提出了一种统一的时空数据存储格式，即原子文件。在此基础上，我们引入了LibCity，这是一个统一而全面的城市时空预测开源库，包括55个时空数据集和65个时空预测模型，涵盖了城市时空预测的9个主流子任务。通过使用LibCity进行广泛的实验，我们建立了一个全面的模型性能排行榜，确定了时空预测的有前途的研究方向。

据我们所知，LibCity是第一个用于城市时空预测的开源库，为探索和开发时空预测模型提供了有价值的工具。未来，我们将不断拓展LibCity，为时空预测领域做出贡献。例如，我们可以涵盖更多的时空预测任务，例如气候预测、空气质量预测、盗窃预测等。

## BibTex

```tex
@misc{jiang2024libcity,
      title={LibCity: A Unified Library Towards Efficient and Comprehensive Urban Spatial-Temporal Prediction}, 
      author={Jiawei Jiang and Chengkai Han and Wenjun Jiang and Wayne Xin Zhao and Jingyuan Wang},
      year={2024},
      eprint={2304.14343},
      archivePrefix={arXiv},
      primaryClass={cs.LG}
}
```
